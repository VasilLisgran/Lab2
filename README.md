## Отчёт по лабораторной работе № 2

### № группы: ПМ-2502

### Выполнил: Калинкин Василий Артёмович

Вариант: 8
---
Оглавление:
- [Задание 1](#задание-1)
- [Задание 2](#задание-2)
- [Задание 3](#задание-3)
- [Задание 4](#задание-4)
---

# Задание 1
### 1.Постановка задачи
- Условие 
    >Ваша задача – посмотреть, какие значения принимает последовательность при разных a0 и n, вывести закономерность, по которой строится последовательность и запрограммировать ее самостоятельно.
  Ограничение сверху на n – искусственное, чтобы не упал весь сайт (а вы можете выбрать любое разумное ограничение самостоятельно). Если на ваш запрос сервер пятисотит (HTTP 500), значит ваша последовательность быстро растет, и питон сломался обрабатывать ее элементы, попробуйте вывести еще меньше элементов.

- Что необходимо сделать:
- Выявить закономерность в последовательностях от введённых `a0` и `n` и реализовать алгоритм для построения последовательности для любых входных значений

- Для определения закономерности будем вводить разные входные значения `a0` и `n` и анализировать полученные последовательности
- При вводе разных значений `a0` заметим, что каждое последующее число равняется сумме цифр предыдущего числа, умноженной на 5
### 2. Входные и выходные данные

#### Данные на вход

По условию на вход подаются два целых числа: `a0`, 0 < `n` < 100


| Число |  Тип | Нижняя граница    | Верхняя граница  |
|-------|-----|-------------------|------------------|
| a0    |   ℤ | -2<sup>31</sup>-1 | 2<sup>31</sup>-1 |
| n     |    ℤ | 1                 | 100              |


#### Данные на выход

Программа будет возвращать целые числа

| Число | Тип | Нижняя граница | Верхняя граница  |
|-------|----|-------|------------------|
| a     |  ℤ  | 0     | 2<sup>31</sup>-1 |

### 3. Выбор структуры данных

Программа на вход получает 2 натуральных числа, поэтому для их хранения достаточно выделить 2 переменные (a0, n)
типа int. Функция, выполняющая алгоритм также будет обрабатывать целое число 'c'

| Число | Название переменной |Тип переменной|
|-------|---------------------|--------------|
| a0    | a0                  |     int      |
| n     | n                   |     int      |
| c     | c                   |     int      |

Результат есть числа целые 

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| a0    | a0                  | int            |

### 4. Алгоритм

#### Алгоритм выполнения программы

1. Ввод данных:    
   Программа считывает 2 натуральных числа a0 , n переменные которых названы соотвественно a0, n.

2. Выполнение цикла:    
   Программа на каждом шаге выводит на экран результат выполнения подпрограммы и задаёт следующее входное число в подпрограмму
3. Подпрограмма:   
Подпрограмма переводит число в абсолютную форму и прибавляет к результирующему числу `c` произведение каждого разряда числа умноженного на 5
### 5. Код программы
```java
import java.util.Scanner;

public class Lab1 {
    static Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        int a0 = scanner.nextInt();
        int n = scanner.nextInt();

        for (int i = 0; i < n-1; i++) {
            System.out.print(sumOfDigits(a0) + ", ");
            a0 = sumOfDigits(a0);
        }
        System.out.println(sumOfDigits(a0));
    }
    public static int sumOfDigits(int a){
        a = Math.abs(a);
        int sum = 0;
        do {
            sum += (a %10)*5;
            a = a / 10;
        }
        while(a>0);
        return sum;
    }
}
````
### 6.Тесты
#### Тест 1: a0 = 0,n = 5
##### Вывод: `0, 0, 0, 0, 0`
#### Тест 2: a0 = 3,n = 6
##### Вывод: `15, 30, 15, 30, 15, 30`
#### Тест 3: a0 = -1,n = 10
##### Вывод: `5, 25, 35, 40, 20, 10, 5, 25, 35, 40`
#### Тест 4: a0 = 11,n = 10
##### Вывод: `10 5 25 35 40 20 10 5 25 35`
#### Тест 5: a0 = -11,n = 6
##### Вывод: `10, 5, 25, 35, 40, 20`
#### Тест 6: a0 = 1035,n = 33
##### Вывод: `45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45 45`

# Задание 2
### 1.Постановка задачи
- Условие
>С клавиатуры вводится заглавная буква латинского алфавита и натуральное число N (N < 100). Вывести подряд N букв латинского алфавита, начиная с введенной. Если при этом буквы доходят до конца алфавита, счет продолжается с ‘A’. Буквы на нечетных позициях должны выводиться заглавными, а на четных – строчными.

- Данная задача предполагает анализ введённых значений: вывод указанного числа букв после указанной буквы с заглавным/маленьким регистром в зависимости от нечётности/чётности позиции

- Чтобы получить нужную строку, необходимо также анализировать букву на сходство с последней в алфавите. Если последняя буква алфавита прописная, то чтобы получить следующую, прибавляем к индексу буквы число 7 (то есть индекс Z = 90. А индекс a = 97. Видно из таблицы unicode). Если последняя буква алфавита заглавная, то чтобы получить следующую, вычитаем из индекса буквы число 57 (то есть индекс z = 122. А индекс A = 65. Видно из таблицы unicode). 

### 2. Входные и выходные данные

#### Данные на вход

Согласно условию задачи на вход подаётся строка, состоящая из символа и натурального числа длиной не более 100

| Переменная | Тип    | Нижняя граница | Верхняя граница |
|------------|--------|----------------|-----------------|
| str         | String | -              | -               |


#### Данные на выход

На выходе мы получаем строку образованную из символов типа `char`

| Переменная | String  | Нижняя граница | Верхняя граница |
|-------|------|----------------|-----------------|
| result | char | -              | -               |

### 3. Алгоритм

#### Алгоритм выполнения программы

1. Ввод данных:    
   Программа считывает строку, потом формирует значение `count` в зависимости от количества разрядов в строке, используя условные операторы и перевод из `char` в `int`. 

2. Вывод данных:
    Циклически проверяем позицию буквы на чётность и на сходство с последним символом в алфавите. Выводим символ отличающийся на такое количество от изначального, сколько шагов цикла уже пройдена, попутно меняя регистр.

### 4.Код программы
```java
import java.util.Scanner;

public class Lab2 {
    static Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        String str = scanner.nextLine();
        char character = str.charAt(0);
        str = str.replace(str.charAt(0), '0');

        int number = Integer.parseInt(str);

        int intRepresentation = (int)(character);
        String result = "";
        result += character;

        for (int i = 0; i < number-1; i++) {
            if (i % 2 == 0) {
                intRepresentation += 33;
                if(intRepresentation == 91 || intRepresentation == 123){
                    intRepresentation = 97;
                }
            }
            else {
                intRepresentation -= 31;
                if(intRepresentation == 91 || intRepresentation == 123){
                    intRepresentation = 65;
                }
            }
            char ch = (char) (intRepresentation);
            result += ch;
        }
        System.out.println(result);
    }
}

```
### 5.Тесты
#### Тест 1: bc = S33. Вывод: `StUvWxYzAbCdEfGhIjKlMnOpQrStUvWxY`
#### Тест 2: bc = W11. Вывод: `WxYzAbCdEfG`
#### Тест 3: bc = A1. Вывод: `A`


# Задание 3
### 1.Постановка задачи
- Условие
>Система нагревается и охлаждается по тикам. На каждом тике значение
> температуры T сначала увеличивается на L, затем уменьшается 
> на величину ⌊T * alpha / 100⌋ (⌊n⌋ – целая часть от n). 
> Безопасной зоной считается состояние, когда температура 
> не превышает порога H. Требуется определить, через сколько
> тиков температура впервые вернется в безопасную зону и какое
> значение будет иметь T в этот момент. Если опустить температуру
> до уровня H и ниже невозможно, выведите NO.

- Если температура станет не больше необходимого порога, то нужно вывести значения температуры и количество тиков, если температура не стремится к заданному значению, то выводим сообщение о невозможности выполнения условия.
### 2. Входные и выходные данные

#### Данные на вход

Согласно условию задачи на вход подаются четыре целых числа (H,alpha,L,T0)

| Число |  Тип | Нижняя граница  |Верхняя граница |
|-------|----|-----------------|----------------|
| H     |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|
| alpha |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|
| L     |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|
| T0    |   ℤ | -2<sup>31</sup>               |2<sup>31</sup>-1|


#### Данные на выход

Программа выводит два целых числа

| Число |Тип|Нижняя граница|Верхняя граница|
|-------|---|--------------|--------------|
| tick  | ℤ |     0        |    2<sup>31</sup>-1          |
| T     |   ℤ | -2<sup>31</sup> |2<sup>31</sup>-1|

### 3. Выбор структуры данных

Для входных данных выделим переменные типа int, также нам понадобиться три переменных для хранения счётчиков и  значения результирующего числа 

| Число | Название переменной |Тип переменной|
|-------|---------------------|--------------|
| H     | H                   |     int      |
| alpha | alpha               |     int      |
| L     | L                   |     int      |
| T0    | T0                  |     int      |
| T     | T                   |     int      |
| count | count               |     int      |

Результат - целое число (если ответ возможен)

| Число | Название переменной| Тип переменной|
|-------|-------------------|--------------|
| count | count             |     int      |

Или строковое выражение "NO".

### 4. Алгоритм

1. Ввод данных:    
   Программа считывает 4 целых числа: H, alpha, L, T0 переменные которых названы соотвественно.

2. Цикл:    
Программа на каждом шагу цикла проверяет количество циклов с ограничением в 1000000000 тиков, которое я задал, так как если температура не вошла в необходимую зону при выполнении такого количества шагов, то она уже вряд ли достигнет его. На каждом шагу цикла проверяем, стала ли текущая температура не больше необходимого порога, если да, то выводим значения, прибавляем 1 к счётчику `m`, который является индикатором выполнения условия, и завершаем цикл, если нет, то выполняем указанные операции и прибавляем 1 к счётчику тиков.
3. Если индикатор выполнения цикла m остался нулевым, то выводим `NO`.

### 5.Код программы
```java
import java.util.Scanner;

public class Lab3 {
    public static Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        int H = scanner.nextInt();
        int alpha = scanner.nextInt();
        int L = scanner.nextInt();
        int T0 = scanner.nextInt();

        int T = T0;
        int count = 0;
        int m = 0;
        do{
            if(T < H) {
                System.out.println(count);
                m++;
                break;
            }
            T = T + L;
            T = T - (T*alpha)/100;
            count++;
        }
        while (count < 1000000000);

        if(m == 0) System.out.println("NO");
    }
}
```
### 6.Тесты
#### Тест 1: `100 10 15 155` Вывод: `NO`
#### Тест 2: `100 30 15 155` Вывод: `2, 94`
#### Тест 3: `100 30 15 1500` Вывод: `9, 96`
#### Тест 4: `500 10 5 13000` Вывод: `32, 494`
#### Тест 5: `600 4 10 5000` Вывод: `65, 586`
#### Тест 5: `800 3 80 9000` Вывод: `NO`

# Задание 4
### 1.Постановка задачи
- Условие задачи
>Дан массив из n чисел. Найти элемент,
> значение которого ближе всего к среднему
> арифметическому остальных элементов. Вывести 
> его значение и расположение в массиве.

- Задача предполагает подсчёт разницы между каждым числом в массиве и средним арифметическим массива без этого числа, при этом сохраняя значение его порядкового номера.

- Нужно вывести минимальную разницу и порядковый номер элемента в массиве, который образует эту разницу.

### 2. Входные и выходные данные

#### Данные на вход

Целое число `n` - количество элементов в массиве

| Число |  Тип   |Нижняя граница|Верхняя граница |
|-------|--------|--------------|----------------|
| n     |   ℕ    |      1       |2<sup>31</sup>-1|

#### Данные на выход
Для выходных данных используется ццелочисленная переменная index, как для необходимого элемента, так и для позиции его позиции в массиве

| Число |Тип|Нижняя граница|Верхняя граница|
|-------|---|--------------|--------------|
| index | ℤ |     0        |       2<sup>31</sup>-1       |

### 3. Выбор структуры данных
Для хранения длины массива будем использовать переменную `n` типа данных `int`, сам массив также будет целочисленным. Для хранения промежуточных значений буду использовать две целочисленных переменных `index` и `znachenie` типа `int`.  

| Число     | Название переменной |Тип переменной|
|-----------|---------------------|--------------|
| n         | n                   |     int      |
| numbers   | numbers             |     int[]    |
| array     | array               |     int[]    |
| sum       | sum                 |     int      |
| average   | average             |     double   |
| closestInd| closestInd          |     int      |
| start     | start               |     double   |

Результат - число

| Число | Название переменной | Тип переменной |
|-------|---------------------|----------------|
| numbers[closestInd] | -     | int            |

### 4. Алгоритм

#### Алгоритм выполнения программы

1.Ввод данных:
    Считываем целое число n - количество элементов
    Создаём массив numbers размером n
    Заполняем массив значениями с клавиатуры
    
2. Вычисление разниц для каждого элемента:
    Для каждого элемента i от 0 до n-1:
    Обнуляем сумму sum = 0
    Суммируем все элементы кроме текущего (j ≠ i)
    Вычисляем среднее: average = sum / (n-1)
    Сохраняем в массив raznosti[i] модуль разности: |numbers[i] - average|
   
3. Поиск минимальной разницы:
   Устанавливаем начальные значения: closestInd = 0, start = array[0]
    Для каждого элемента от 1 до n-1:
        Если array[i] < start, обновляем: start = array[i], closestInd = i

4.Вывод результата:
    Выводим значение найденного элемента: numbers[closestInd]


### 5.Код программы
```java
import java.util.Arrays;
import java.util.Scanner;

public class Lab4 {
    public static Scanner scanner = new Scanner(System.in);
    public static void main(String[] args) {
        int n = scanner.nextInt();
        int[] numbers = new int[n];
        double[] raznosti = new double[n];

        double sum = 0;

        for (int i = 0; i < n; i++) {
            numbers[i] = scanner.nextInt();
        }

        for (int i = 0; i < n; i++) {
            sum = 0;
            for (int j = 0; j < n; j++) {
                if(j!=i) sum+=numbers[j];
            }
            double average = sum / (n-1);
            raznosti[i] = Math.abs(numbers[i] - average);
        }

        int closestInd = 0;
        double start = raznosti[0];
        for (int i = 1; i < n; i++) {
            if(raznosti[i] < start) {
                start = raznosti[i];
                closestInd = i;
            }
        }

        System.out.println(numbers[closestInd]);
    }
}
```
### 6.Тесты
#### Тест 1: `5 12 13 14 15 16` Вывод: `14, 3 `
#### Тест 2: `4 5 5 5 5` Вывод: `5, 1`
#### Тест 3: `1 42` Вывод: `42, 1`
#### Тест 4: `3 1000000 1000001 999999` Вывод: `Значение искомого элемента: 4    Этот элемент находится на 4 позиции`
